---
title: "Recreating the dynbenchmark figures"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Recreating the dynbenchmark figures}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this vignette, we will use `funkyheatmap` to reproduce the figures by @comparisonsinglecell_saelens2019.

## Load data

This data was generated by running the [`data-raw/dynbenchmark_data.R`](https://github.com/dynverse/funkyheatmap/blob/main/data-raw/dynbenchmark_data.R) script.
It fetches the latest results from the [`dynbenchmark_results`](https://github.com/dynverse/dynbenchmark_results) repository and stores the data inside the `funkyheatmap` package.

```{r load-data}
library(funkyheatmap)
library(kableExtra)

data("dynbenchmark_data")
```

## Process results

The results data is one big data frame.

```{r}
data <- dynbenchmark_data$data
kable(data, "html") %>%
  scroll_box(width = "150%", height = "600px")
```

It's possible to preview the results by selecting a few columns, but the
resulting data frame will not have any of the desired formatting.

```{r}
preview_cols <- c(
  "id",
  "benchmark_overall_norm_correlation",
  "benchmark_overall_norm_featureimp_wcor",
  "benchmark_overall_norm_F1_branches",
  "benchmark_overall_norm_him",
  "benchmark_overall_overall"
)
g <- funky_heatmap(data[,preview_cols])
```


```{r include=FALSE}
# set width and height for upcoming plot
knitr::opts_chunk$set(fig.width = g$width, fig.height = g$height)
```

```{r heatmap_preview}
g
```

## Process column info

Apart from the results themselves, the most important additional info is the
column info. This data frame contains information on how each column should be
formatted.

```{r}
column_info <- dynbenchmark_data$column_info
kable(column_info) %>%
  scroll_box(width = "150%", height = "600px")
```

With just the data and the column info, we can already get a pretty good 
funky heatmap:

```{r}
g <- funky_heatmap(data, column_info = column_info)
```


```{r include=FALSE}
# set width and height for upcoming plot
knitr::opts_chunk$set(fig.width = g$width, fig.height = g$height)
```

```{r heatmap_withcolinfo}
g
```

## Finetuning the visualisation

The figure can be finetuned by grouping the columns and rows and specifying
custom palettes. 

Column grouping:

```{r}
column_groups <- dynbenchmark_data$column_groups
kable(column_groups)
```

Row info:

```{r}
row_info <- dynbenchmark_data$row_info
kable(row_info)
```

Row grouping:
```{r}
row_groups <- dynbenchmark_data$row_groups
kable(row_groups)
```

Palettes:
```{r}
palettes <- dynbenchmark_data$palettes
print(palettes)
```

## Generate funky heatmap

The resulting visualisation contains all of the results by @comparisonsinglecell_saelens2019
in a single plot.

Note that Figures 2 and 3 from the main paper and Supplementary Figure 2 were generated by making different subsets
of the `column_info` and `column_groups` objects.
```{r make-plot}
g <- funky_heatmap(
  data = data,
  column_info = column_info,
  column_groups = column_groups,
  row_info = row_info,
  row_groups = row_groups,
  palettes = palettes,
  col_annot_offset = 3.2
)
```


```{r include=FALSE}
# set width and height for upcoming plot
knitr::opts_chunk$set(fig.width = g$width, fig.height = g$height)
```

```{r heatmap}
g
```

`funkyheatmap` automatically recommends a width and height for the generated plot.
To save your plot, run:

``` r
ggsave("path_to_plot.pdf", g, device = cairo_pdf, width = g$width, height = g$height)
```

## References